# Linux 内存管理与游戏破解 Demo

这个项目是为了配合博客文章《从Linux内存管理去理解游戏作弊》而创建的，展示了游戏破解的基本原理和方法。

[从Linux内存管理去理解游戏作弊](https://kiosk007.top/post/%E4%BB%8Elinux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%BB%E7%90%86%E8%A7%A3%E6%B8%B8%E6%88%8F%E4%BD%9C%E5%BC%8A/#%E4%B8%80-%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E6%B8%B8%E6%88%8F%E5%BC%80%E5%A7%8B)

该文章详细介绍了游戏破解的技术原理和防护措施。

## 项目背景

本项目包含几个简单的演示程序，用于说明游戏内存修改的原理和方法：
- 如何通过内存读写修改游戏状态
- 如何使用不同的技术手段进行游戏作弊
- 如何理解Linux内存管理机制在游戏安全中的作用

## 文件说明

### 游戏演示程序

- `game-demo.c` - 经典的内存修改演示游戏
  - 一个简单的生命值游戏，包含全局变量 `player_health`
  - 程序会输出进程ID和内存地址，便于后续的内存修改
  - 生命值会不断减少，模拟游戏场景

- `game-demo-sig.c` - 信号控制版本的游戏
  - 同样包含全局变量 `player_health`
  - 通过信号（SIGUSR1）控制生命值变化
  - 需要通过 `kill -SIGUSR1 PID` 命令来发送伤害信号

### 破解工具

- `hacker_trainer-mem.c` - 通过 `/proc/[pid]/mem` 修改内存
  - 直接访问进程的内存文件进行读写
  - 可以将目标进程的游戏生命值恢复到满值

- `hacker_trainer-ptrace.c` - 使用 `ptrace` 系统调用
  - 使用 `ptrace` 附加到目标进程
  - 读取和修改进程内存
  - 更加隐蔽和安全的内存修改方式

## 编译和运行

### 编译游戏和破解工具

```bash
# 编译游戏
gcc -o game game-demo.c

# 编译信号版本游戏
gcc -o game-sig game-demo-sig.c

# 编译内存修改工具
gcc -o mem-hack hacker_trainer-mem.c

# 编译 ptrace 工具
gcc -o ptrace-hack hacker_trainer-ptrace.c
```

### 运行示例

1. 启动游戏:
```bash
./game
# 输出例如:
# --- 简易游戏Demo (PID: 1234) ---
# 玩家血量 (player_health) 地址: 0x40403c
# --------------------------------
# 当前血量: 100
# 当前血量: 98
# ...
```

2. 在另一个终端中使用破解工具:
```bash
# 使用内存修改工具 (参数: PID 地址)
./mem-hack 1234 0x40403c

# 或使用 ptrace 工具
./ptrace-hack 1234 0x40403c
```

## 技术原理

### 使用 `/proc/[pid]/mem`

- Linux 内核提供了 `/proc` 文件系统来访问进程信息
- 每个进程都有一个 `/proc/[pid]/mem` 文件，允许直接读写进程内存
- 需要相应的权限才能访问其他进程的内存

### 使用 `ptrace` 系统调用

- `ptrace` 是调试器和进程监控工具的核心系统调用
- 允许一个进程观察和控制另一个进程的执行
- 提供了读写内存和寄存器的功能
- 更安全，但需要更复杂的编程

## 安全注意事项

- 本项目仅供学习和研究目的
- 了解游戏破解原理有助于开发更安全的游戏
- 在实际游戏中，应采用服务器验证、加密等技术防止作弊
- 使用这些技术时需确保拥有合法权限


